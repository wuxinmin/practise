<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<!-- 
    函数下的属性是prototype
    对象下的属性是__proto
 -->
<script>
    //类：类名首字母大写，属性放在构造函数中，方法放在原型下
    //构造函数：用new关键字定义的函数称之为构造函数
    //为什么使用构造函数：为了得到一些具有相同属性的对象，通过构造函数来创建比较方便
    function Person(name) {
        this.name = name;
        //方法写在构造函数中，每创建一个实例化对象都会创建一个新的函数，对内存有损耗，为了提升性能需要把方法放到原型下
        /* this.say = function(){
            console.log('say hello...');
        } */
    }
    //原型是为了解决实例化对象不能共享的缺点
    Person.prototype.eating = function () {
        console.log(this.name + ' is eating...');
    }
    //实例化对象
    var p1 = new Person('zs');

    //console.dir()  会输入对象下所有的属性及属性的值
    console.dir(Person);//可以看到Person下会有一个属性prototype
    console.dir(p1.constructor);//Person  p1.constructor又指向Person，p1.constructor可以获取到实例化对象的构造函数
    console.log(Person.prototype);//prototype下有一个constructor属性，这个属性的值就是构造函数（Person）；
    //实例化对象p1下有一个__proto__属性,它指向Person下的prototype属性
    console.log(p1.__proto__===Person.prototype);//输出true
    /* //普通函数
    function fun(){
        console.log(48239856);
    }
    //调用
    fun(); */

    //普通函数  必须有返回值才能拿到
    /* function person2(name){
        this.name = name;
    }
    var p2 = person2('zs');
    console.log(p2);//找不到undefined */



    //此处 必须有返回值才能拿到构造函数
    function person3(name){
        return{
            name:name
        }
    }
    var p3 = person3('zs');
    console.log(p3.constructor);//它的构造函数是Object（相当于金字塔顶端）所有的源头  所有的函数都继承自Object
</script>

</html>